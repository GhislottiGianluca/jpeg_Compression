	
\part{Implementazione della DCT2}

Lo scopo di questa parte del progetto è stato quello di implementare la nostra versione della DCT2 e confrontare i tempi di esecuzione con quelli di una libreria che implementa la versione fast della DCT2. La libreria utilizzata è la FFTW \cite{fftw}, scritta in C.

Per testare la scalatura eseguita da FFTW, applichiamo una dct e una idct su una matrice di partenza per poi testare se tali valori corrispondono tra loro. Dalla differenza dei risultati ottenuti, abbiamo osservato che viene introdotto un errore durante le operazioni non superiore ad 1e$^{-14}$. Consideriamo tale errore di approssimazione accettabile, osservando che la differenza tra 2 double successivi è pari a 2.22045e$^{-16}$.

L'implementazione "fatta in casa" della DCT2 e dell'analoga IDCT2 è stata implementata tramite la sua versione ad una singola dimensione, infatti una 2-D discrete cosine transform è semplicemente una doppia applicazione della versione ad una dimensione. Così facendo, abbiamo codificato la cosine transform ad una singola dimensione, per poi chiamarla sia sulle righe che sulle colonne, ottenendo in questo modo una 2-D cosine transform.

\section{Codice}

Il codice implementato per eseguire la DCT é il seguente:


\begin{lstlisting}[gobble=1]
	void dct(int N, double *in, double *out, int jump = 1) {
		
		double *f = new double[N];
		
		for (int i = 0; i < N; ++i) {
			f[i] = in[i * jump];
		}
		
		for (int i = 0; i < N; ++i) {
			
			double a_i = 0;
			
			for (int j = 0; j < N; ++j) {
				a_i +=  f[j] * cos(i * M_PI * (2 * j + 1) / (2 * N));
			}
			
			out[i * jump] = a_i;
		}
		
		delete[] f;
	}
\end{lstlisting}

Siccome l'applicazione di 2 dct genera la DCT2, di seguito si trova la sua implementazione:

\begin{lstlisting}[gobble=1]
	void dct2(int N, int M, double *in, double *out) {
		for (int i = 0; i < N * M; ++i) {
			out[i] = 0;
		}
		
		// Rows
		for (int i = 0; i < N; ++i) {
			dct(M, in + i * M, out + i * M, 1);
		}
		
		// Columns
		for (int i = 0; i < M; ++i) {
			dct(N, out + i, out + i, M);
		}
	}
\end{lstlisting}

Le matrici passate in input vengono memorizzate in modalità row major, in questo modo è sufficiente usare l'allocazione di un singolo vettore per contenere tutte le celle della matrice. Infatti per tale motivo è stato aggiunto il parametro \textit{jump} che permette di saltare da una riga alla successiva, in questo modo si può iterare sulle colonne mantenendo la DCT universale.



\section{Test}

All'interno del codice sono stati aggiunti una serie di test (tramite l'uso delle assert) all'interno dei quali viene verificato l'esito dell'applicazione della DCT e della IDCT sulla matrice e sul vettore fornito. Successivamente l'esecuzione del codice prosegue verificando i tempi e generando un csv contenente i risultati delle esecuzioni su matrici man mano sempre più grandi. Dai risultati presenti nell'immagine \ref{fig:timings}, si può osservare come l'implementazione "fatta in casa" (in figura denominata \textit{Slow}) abbia effettivamente un andamento più esponenziale rispetto la liberia (in figura \textit{Fast}). Un fenomeno particolare che si osserva è che mentre la matrice è ancora di dimensioni molto ristrette la dct implementata fatta da noi supera quella fast. Una possibile ragione è che la FFTW utilizza delle tecniche numeriche sulla trasformata per ridurre il numero di operazioni necessarie, il che porta ad una maggiore efficienza per matrici di elevate dimensioni. Analogamente, nelle matrici di piccole dimensioni, è ragionevole pensare che l'applicazione di queste tecniche introducano un overhead che porta ad avere una performance peggiore rispetto alla DCT2 standard.

\begin{figure}[ht]
	\centering
	\label{fig:timings}	
	\includegraphics[scale=0.7]{figures/timings}
	\caption{Tempi}
\end{figure}

\FloatBarrier