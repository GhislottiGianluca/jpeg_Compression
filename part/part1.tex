	
\part{Implementazione della DCT2}

Lo scopo di questa parte del progetto è stato quello di implementare la nostra versione della DCT2 e confrontare i tempi di esecuzione con quelli di una libreria che implementa la versione fast della DCT2. La libreria utilizzata è la FFTW \cite{fftw}.

Per testare la scalatura eseguita da FFTW, applichiamo una dct e una idct su una matrice di partenza per poi testare se tali valori corrispondono tra loro. Dalla differenza dei risultati ottenuti, abbiamo osservato che viene introdotto un errore durante le operazioni non superiore ad 1e$^{-14}$. Consideriamo tale errore di approssimazione accettabile, osservando che la differenza tra 2 double successivi è pari a 2.22045e$^{-16}$.

L'implementazione "fatta in casa" della DCT2 e dell'analoga IDCT2 è stata implementata tramite la sua versione ad una singola dimensione, infatti una 2-D discrete cosine transform è semplicemente una doppia applicazione della versione ad una dimensione. Così facendo, abbiamo codificato la cosine transform ad una singola dimensione, per poi chiamarla sia sulle righe che sulle colonne, ottenendo in questo modo una 2-D cosine transform.

\section{Informazioni sulla libreria}

La libreria scelta, come accennato precedentemente, è la FFTW, il cui nome è l'abbreviativo di \textit{Fast Fourier Transform in the West}. Infatti si dichiara essere una delle implementazioni più veloci della Fastest Fourier Transform. Tali risultati sono stati possibili grazie ad un ottimizzazione particolare degli algoritmi, che sfruttano alcune istruzioni specifiche dei vari processori ottimizzate per la risoluzione numerica.

L'implementazione effettiva risale al '97, nonostante ciò gode di particolare popolarità su Github\cite{Github} e ha vinto numerosi premi, tra cui il \textit{1999 J.H Wilkinson Prize for Numerical Software}, il quale viene conferito, una volta sola ogni 4 anni, al software che "best addresses all phases of the preparation of high quality numerical software", ovvero al programma che meglio copre tutte le fasi di un software numerico. Inoltre il paper correlato alla libreria "A Fast Fourier Transform Compiler"\cite{fftw_paper} ha ricevuto il premio di "Most Influential PLDI Paper" nel 2009, con un totale di circa 2000 download e 400 citazioni.

\section{Implementazione custom}

Il codice implementato per eseguire la DCT, secondo la definizione de coefficienti vista a lezione, è il seguente:


\begin{lstlisting}[gobble=1]
	void dct(int N, double *in, double *out, int jump = 1) {
		
		double *f = new double[N];
		
		for (int i = 0; i < N; ++i) {
			f[i] = in[i * jump];
		}
		
		for (int i = 0; i < N; ++i) {
			
			double a_i = 0;
			
			for (int j = 0; j < N; ++j) {
				a_i +=  f[j] * cos(i * M_PI * (2 * j + 1) / (2 * N));
			}
			
			a_i /= (i == 0 ? N : N/2);
			out[i * jump] = a_i;
		}
		
		delete[] f;
	}

\end{lstlisting}

Siccome l'applicazione di 2 DCT genera la DCT2, di seguito si trova la sua implementazione:

\begin{lstlisting}[gobble=1]
	void dct2(int N, int M, double *in, double *out) {
		for (int i = 0; i < N * M; ++i) {
			out[i] = 0;
		}
		
		// Rows
		for (int i = 0; i < N; ++i) {
			dct(M, in + i * M, out + i * M, 1);
		}
		
		// Columns
		for (int i = 0; i < M; ++i) {
			dct(N, out + i, out + i, M);
		}
	}
\end{lstlisting}

Il codice della DCT prende in input il puntatore alla matrice di output per fare in modo che la DCT2 possa eseguire due DCT in place, ovvero scrivendo due volte sulla stessa matrice evitando ulteriori allocazioni di memoria.

Per evitare il calcolo del prodotto scalare delle basi con sè stesse, inoltre, abbiamo controllato direttamente l'indice della frequenza: se questo è 0, allora il prodotto scalare sarà N, altrimenti corrisponderà sempre a $\frac{N}{2}$.

Nell'applicazione della DCT2, le matrici sono state organizzate in modalità row major. Ciò ha però richiesto una modifica nell'accesso della "matrice logica", infatti se scorrere le righe basterà muoversi di un passo nel vettore, per scorrere sulle colonne sarà invece necessario eseguire un salto pari alla lunghezza di una riga. Per questo motivo all'interno del metodo relativo alla DCT è stato aggiunto il parametro \textit{jump}, che permette appunto di applicare la DCT sia sulle righe che sulle colonne, impostando rispettivamente il valore a uno, oppure ad M, con M pari al numero di colonne totali.

\section{Test}

All'interno del codice sono stati aggiunti una serie di test (tramite l'uso delle assert) all'interno dei quali viene verificato l'esito dell'applicazione della DCT e della IDCT sulla matrice e sul vettore fornito. Successivamente l'esecuzione del codice prosegue verificando i tempi e generando un csv contenente i risultati delle esecuzioni su matrici man mano sempre più grandi.

In Figura \ref{fig:timings} si può osservare come l'implementazione "fatta in casa" (in figura denominata \textit{Slow}) segua un incremento effettivamente molto più ripido di quello della libreria che implementa la versione Fast. In particolare, le due funzioni chiamate "Fit" sono curve della forma $ax^3$ per la versione lenta e $bx^2 \log{x}$  per quella della libreria, con $a$ e $b$ parametri del fitting. La vicinanza tra le funzioni e gli andamenti reali dei tempi ci suggerisce che, effettivamente,vengono rispettati gli andamenti asintotici dati dalla teoria dei due algoritmi.
 
 Un fenomeno particolare che si osserva è che mentre la matrice è ancora di dimensioni molto ristrette, la DCT implementata fatta da noi supera quella fast. Una possibile ragione è che la FFTW utilizza delle tecniche numeriche sulla trasformata per ridurre il numero di operazioni necessarie, il che porta ad una maggiore efficienza per matrici di elevate dimensioni. Analogamente, è ragionevole pensare che l'applicazione di queste tecniche introducano un overhead che, su matrici ristrette, porta ad avere performance peggiori rispetto alla DCT2 standard.

FFTW non esegue lo stesso algoritmo ad ogni chiamata della DCT: questo è il motivo per cui il grafico della versione fast non è liscio come quello della versione "fatta in casa", che esegue sempre lo stesso tipo di istruzioni indipendentemente dalla matrice/vettore in input.
È importante puntualizzare inoltre che, anche se questo non influisce sui tempi, i risultati delle DCT e DCT2 sono diversi tra la versione fast e la nostra: infatti, la libreria presa in considerazione utilizza un tipo di scaling della matrice dei coefficienti diverso da quello visto a lezione.

\begin{figure}[ht]
	\centering
	\includegraphics[width=\textwidth]{figures/timings}
	\caption{Tempi}
	\label{fig:timings}	
\end{figure}

\FloatBarrier